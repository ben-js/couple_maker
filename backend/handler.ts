// ÎçîÎØ∏ Îç∞Ïù¥ÌÑ∞
// User ÌÉÄÏûÖÏùÑ email Í∏∞Î∞òÏúºÎ°ú ÌÜµÏùº
// ÌöåÏõêÍ∞ÄÏûÖ/Î°úÍ∑∏Ïù∏ Î™®Îëê email, passwordÎßå ÏÇ¨Ïö©

import fs from 'fs';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { camelToSnakeCase, snakeToCamelCase } from './utils/caseUtils';
import { User, UserProfile, UserPreferences, MatchingRequest, MatchPair, Review, ReviewStats, UserStatusHistory, PointsHistory, ApiResponse } from './types';
import { UserStatus } from './types';

const usersPath = path.join(__dirname, 'data/users.json');
const profilesPath = path.join(__dirname, 'data/profiles.json');
const preferencesPath = path.join(__dirname, 'data/preferences.json');
const matchingRequestsPath = path.join(__dirname, 'data/matching-requests.json');
const matchPairsPath = path.join(__dirname, 'data/match-pairs.json');
const reviewsPath = path.join(__dirname, 'data/reviews.json');
const reviewStatsPath = path.join(__dirname, 'data/review-stats.json');
const userStatusHistoryPath = path.join(__dirname, 'data/user-status-history.json');
const pointsHistoryPath = path.join(__dirname, 'data/points-history.json');
const logsPath = path.join(__dirname, 'data/logs.json');
const termsPath = path.join(__dirname, 'data/terms.json');
const privacyPath = path.join(__dirname, 'data/privacy.json');
const customerServicePath = path.join(__dirname, 'data/customer-service.json');

function readJson(filePath: string) {
  return JSON.parse(fs.readFileSync(filePath, 'utf-8'));
}
function writeJson(filePath: string, data: any) {
  fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
}

// ÎÇ†ÏßúÎ≥Ñ Î°úÍ∑∏ ÌååÏùº ÏÉùÏÑ± Ìï®Ïàò
function getLogFileName(date: Date = new Date()): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}.json`;
}

function getLogFilePath(date: Date = new Date()): string {
  const fileName = getLogFileName(date);
  return path.join(__dirname, 'logs', fileName);
}

// Î°úÍ∑∏ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
function ensureLogDirectory() {
  const logDir = path.join(__dirname, 'logs');
  if (!fs.existsSync(logDir)) {
    fs.mkdirSync(logDir, { recursive: true });
  }
}

async function appendLog({ 
  type, 
  userId = '', 
  email = '', 
  ip = '', 
  hasProfile = false, 
  hasPreferences = false, 
  result = '', 
  message = '', 
  detail = {},
  userAgent = '',
  requestMethod = '',
  requestPath = '',
  requestBody = '',
  responseStatus = 0,
  responseBody = '',
  errorStack = '',
  executionTime = 0,
  sessionId = '',
  action = '',
  screen = '',
  component = ''
}: {
  type: string;
  userId?: string;
  email?: string;
  ip?: string;
  hasProfile?: boolean;
  hasPreferences?: boolean;
  result?: string;
  message?: string;
  detail?: any;
  userAgent?: string;
  requestMethod?: string;
  requestPath?: string;
  requestBody?: string;
  responseStatus?: number;
  responseBody?: string;
  errorStack?: string;
  executionTime?: number;
  sessionId?: string;
  action?: string;
  screen?: string;
  component?: string;
}) {  
  ensureLogDirectory();
  
  const timestamp = new Date();
  const logEntry = {
    // Í∏∞Î≥∏ ÏãùÎ≥Ñ Ï†ïÎ≥¥
    logId: uuidv4(),
    timestamp: timestamp.toISOString(),
    date: timestamp.toISOString().split('T')[0],
    time: timestamp.toISOString().split('T')[1].split('.')[0],
    
    // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥
    userId,
    email,
    sessionId,
    
    // ÏöîÏ≤≠ Ï†ïÎ≥¥
    requestMethod,
    requestPath,
    requestBody: requestBody.length > 1000 ? requestBody.substring(0, 1000) + '...' : requestBody,
    userAgent,
    ip,
    
    // ÏùëÎãµ Ï†ïÎ≥¥
    responseStatus,
    responseBody: responseBody.length > 1000 ? responseBody.substring(0, 1000) + '...' : responseBody,
    
    // Ïï± ÏÉÅÌÉú
    hasProfile,
    hasPreferences,
    
    // Ïï°ÏÖò Ï†ïÎ≥¥
    type,
    action,
    screen,
    component,
    
    // Í≤∞Í≥º Ï†ïÎ≥¥
    result,
    message,
    errorStack,
    executionTime,
    
    // ÏÉÅÏÑ∏ Îç∞Ïù¥ÌÑ∞
    detail: typeof detail === 'object' ? JSON.stringify(detail, null, 2) : detail,
    
    // Î∂ÑÏÑùÏö© ÌÉúÍ∑∏
    tags: {
      isError: result === 'fail' || responseStatus >= 400,
      isSuccess: result === 'success' && responseStatus < 400,
      isUserAction: ['login', 'signup', 'profile_save', 'preferences_save'].includes(type),
      isSystemAction: ['api_call', 'error'].includes(type)
    }
  };

  const logFilePath = getLogFilePath();
  
  try {
    // Í∏∞Ï°¥ Î°úÍ∑∏ ÌååÏùº ÏùΩÍ∏∞
    let logs = [];
    if (fs.existsSync(logFilePath)) {
      try {
        const fileContent = fs.readFileSync(logFilePath, 'utf-8');
        logs = JSON.parse(fileContent);
      } catch (parseError) {
        console.error('Log file parse error, starting fresh:', parseError);
        logs = [];
      }
    }
    
    // ÏÉà Î°úÍ∑∏ Ï∂îÍ∞Ä
    logs.push(logEntry);
    
    // ÌååÏùºÏóê Ï†ÄÏû•
    fs.writeFileSync(logFilePath, JSON.stringify(logs, null, 2));
    
    // ÏΩòÏÜîÏóêÎèÑ Ï∂úÎ†• (Í∞úÎ∞úÏö©)
    const logLevel = logEntry.tags.isError ? 'ERROR' : logEntry.tags.isSuccess ? 'SUCCESS' : 'INFO';
    console.log(`${logLevel} [${logEntry.type}] ${logEntry.action || logEntry.message} - User: ${logEntry.userId} - Time: ${logEntry.executionTime}ms`);
    console.log('appendLog called:', logEntry); // ÎîîÎ≤ÑÍπÖÏö©
  } catch (error) {
    console.error('Log write error:', error);
  }
}

export const hello = async (event: any) => {
  return {
    statusCode: 200,
    body: JSON.stringify(
      {
        message: 'Hello from Serverless Framework!',
        input: event,
      },
      null,
      2
    ),
  };
};

// ÌöåÏõêÍ∞ÄÏûÖ
export const signup = async (event: any) => {
  const req = camelToSnakeCase(JSON.parse(event.body || '{}'));
  const { email, password } = req;
  const users: User[] = readJson(usersPath);
  const user_id = `user-${users.length + 1}`;
  const newUser: User = {
    user_id,
    email,
    password, // Ïã§Ï†úÎ°úÎäî Ìï¥ÏãúÌôîÌï¥Ïïº Ìï®
    is_verified: false,
    has_profile: false,
    has_preferences: false,
    grade: 'general',
    status: 'green',
    points: 100, // ÌöåÏõêÍ∞ÄÏûÖ Ïãú Í∏∞Î≥∏ 100 ÏßÄÍ∏â
    created_at: new Date().toISOString()
  };
  users.push(newUser);
  writeJson(usersPath, users);
  await appendLog({
    type: 'signup',
    userId: user_id,
    email,
    ip: event?.requestContext?.identity?.sourceIp || '',
    result: 'success',
    detail: {},
  });
  return { statusCode: 201, body: JSON.stringify(snakeToCamelCase(newUser)) };
};

// Î°úÍ∑∏Ïù∏
export const login = async (event: any) => {
  const req = camelToSnakeCase(JSON.parse(event.body || '{}'));
  const { email, password } = req;
  const startTime = Date.now();
  const sessionId = uuidv4();
  
  console.log('\n=== üîê Î°úÍ∑∏Ïù∏ API Ìò∏Ï∂úÎê® ===');
  console.log('ÏãúÍ∞Ñ:', new Date().toISOString());
  console.log('üåê ÏöîÏ≤≠ Í≤ΩÎ°ú:', event.requestContext?.http?.path || 'unknown');
  console.log('üìã ÏöîÏ≤≠ Î©îÏÑúÎìú:', event.requestContext?.http?.method || 'unknown');
  console.log('üì¶ ÏõêÎ≥∏ ÏöîÏ≤≠ Î∞îÎîî:', event.body);
  console.log('üîß ÌååÏã±Îêú ÏöîÏ≤≠:', req);
  
  try {
    console.log('üìß Î°úÍ∑∏Ïù∏ ÏãúÎèÑ:', { email, password: password ? '***' : 'empty' });
    
    const users: User[] = readJson(usersPath);
    console.log('üë• Îì±Î°ùÎêú ÏÇ¨Ïö©Ïûê Ïàò:', users.length);
    console.log('üë• Îì±Î°ùÎêú ÏÇ¨Ïö©ÏûêÎì§:', users.map(u => ({ email: u.email, has_profile: u.has_profile })));
    
    const user = users.find(u => u.email === email && u.password === password);
    const ip = event?.requestContext?.identity?.sourceIp || '';
    
    console.log('üîç ÏÇ¨Ïö©Ïûê Í≤ÄÏÉâ Í≤∞Í≥º:', user ? 'Ï∞æÏùå' : 'Ï∞æÏßÄ Î™ªÌï®');
    if (!user) {
      console.log('‚ùå Ïù¥Î©îÏùº Îß§Ïπ≠ Ïã§Ìå®:', users.some(u => u.email === email));
      console.log('‚ùå ÎπÑÎ∞ÄÎ≤àÌò∏ Îß§Ïπ≠ Ïã§Ìå®:', users.some(u => u.password === password));
      const executionTime = Date.now() - startTime;
      const errorMessage = 'ÏûòÎ™ªÎêú Ïù¥Î©îÏùº ÎòêÎäî ÎπÑÎ∞ÄÎ≤àÌò∏';
      const responseBody = JSON.stringify({ 
        error: 'Invalid credentials', 
        input: { email, password: password ? '***' : 'empty' } 
      });

      console.log('‚ùå Î°úÍ∑∏Ïù∏ Ïã§Ìå®: ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå');
      
      await appendLog({
        type: 'login',
        userId: '',
        email,
        ip,
        result: 'fail',
        message: errorMessage,
        detail: {
          reason: 'invalid_credentials',
          attemptedEmail: email,
          userExists: users.some(u => u.email === email),
          totalUsers: users.length
        },
        requestMethod: event.requestContext?.http?.method || 'POST',
        requestPath: event.requestContext?.http?.path || '/login',
        requestBody: JSON.stringify({ email, password: '***' }),
        responseStatus: 401,
        responseBody,
        executionTime,
        sessionId,
        action: 'Î°úÍ∑∏Ïù∏ ÏãúÎèÑ',
        screen: 'AuthScreen',
        component: 'login'
      });
      
      return { statusCode: 401, body: responseBody };
    }
    
    const profiles: UserProfile[] = readJson(profilesPath);
    const preferences: UserPreferences[] = readJson(preferencesPath);
    const hasProfile = user.has_profile;
    const hasPreferences = user.has_preferences;
    
    // ÌîÑÎ°úÌïÑÏóêÏÑú ÏÇ¨Ïö©Ïûê Ïù¥Î¶Ñ Í∞ÄÏ†∏Ïò§Í∏∞
    const userProfile = profiles.find(p => p.user_id === user.user_id);
    const userName = userProfile?.name || 'ÏÇ¨Ïö©Ïûê';
    
    console.log('‚úÖ Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ:');
    console.log('   - User ID:', user.user_id);
    console.log('   - Email:', user.email);
    console.log('   - Name:', userName);
    console.log('   - Has Profile:', hasProfile);
    console.log('   - Has Preferences:', hasPreferences);
    console.log('   - Profile count:', profiles.length);
    console.log('   - Preferences count:', preferences.length);
    
    const executionTime = Date.now() - startTime;
    
    // Í∏∞Î≥∏ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥
    const userResponse: any = {
      user_id: user.user_id,
      email: user.email,
      hasProfile,
      hasPreferences,
      isVerified: user.is_verified,
      grade: user.grade,
      status: user.status,
      points: user.points
    };
    
    // ÌîÑÎ°úÌïÑÏù¥ ÏûàÏúºÎ©¥ Ïù¥Î¶ÑÎèÑ Ìè¨Ìï®
    if (hasProfile && userProfile) {
      userResponse.name = userProfile.name;
    }
    
    const responseBody = JSON.stringify(snakeToCamelCase(userResponse));

    await appendLog({
      type: 'login',
      userId: user.user_id,
      email: user.email,
      ip,
      hasProfile,
      hasPreferences,
      result: 'success',
      message: 'Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ',
      detail: {
        userProfileCount: profiles.length,
        userPreferencesCount: preferences.length,
        userProfileExists: profiles.some(p => p.user_id === user.user_id),
        userPreferencesExists: preferences.some(p => p.user_id === user.user_id)
      },
      requestMethod: event.requestContext?.http?.method || 'POST',
      requestPath: event.requestContext?.http?.path || '/login',
      requestBody: JSON.stringify({ email, password: '***' }),
      responseStatus: 200,
      responseBody,
      executionTime,
      sessionId,
      action: 'Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ',
      screen: 'AuthScreen',
      component: 'login'
    });
    
    return {
      statusCode: 200,
      body: responseBody
    };
  } catch (error: any) {
    const executionTime = Date.now() - startTime;
    const errorMessage = `Î°úÍ∑∏Ïù∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: ${error.message}`;
    const responseBody = JSON.stringify({ 
      error: 'Login processing error', 
      message: error.message 
    });

    console.error('Î°úÍ∑∏Ïù∏ Ï≤òÎ¶¨ Ï§ë ÏóêÎü¨ Î∞úÏÉù:', error);
    console.error('ÏóêÎü¨ Ïä§ÌÉù:', error.stack);

    await appendLog({
      type: 'login',
      userId: '',
      email: '',
      ip: event?.requestContext?.identity?.sourceIp || '',
      result: 'fail',
      message: errorMessage,
      detail: {
        errorType: error.constructor.name,
        errorMessage: error.message
      },
      requestMethod: event.requestContext?.http?.method || 'POST',
      requestPath: event.requestContext?.http?.path || '/login',
      requestBody: event.body || '',
      responseStatus: 500,
      responseBody,
      errorStack: error.stack,
      executionTime,
      sessionId,
      action: 'Î°úÍ∑∏Ïù∏ ÏãúÎèÑ',
      screen: 'AuthScreen',
      component: 'login'
    });

    return { 
      statusCode: 500, 
      body: responseBody
    };
  }
};

// ÌîÑÎ°úÌïÑ Ï†ÄÏû•
export const saveProfile = async (event: any) => {
  const req = camelToSnakeCase(JSON.parse(event.body || '{}'));
  const { user_id, ...profile } = req;
  const profiles: UserProfile[] = readJson(profilesPath);
  const idx = profiles.findIndex(p => p.user_id === user_id);
  if (idx >= 0) profiles[idx] = { user_id, ...profile };
  else profiles.push({ user_id, ...profile });
  writeJson(profilesPath, profiles);

  // users.jsonÏùò has_profile trueÎ°ú Î≥ÄÍ≤Ω
  const users = readJson(usersPath);
  const userIdx = users.findIndex((u: any) => u.user_id === user_id);
  let email = '';
  if (userIdx >= 0) {
    users[userIdx].has_profile = true;
    email = users[userIdx].email;
    writeJson(usersPath, users);
  }

  await appendLog({
    type: 'profile_save',
    userId: user_id,
    email,
    ip: event?.requestContext?.identity?.sourceIp || '',
    result: 'success',
    detail: { profile },
  });

  return { statusCode: 200, body: JSON.stringify({ ok: true }) };
};

// Ïù¥ÏÉÅÌòï Ï†ÄÏû•
export const saveUserPreferences = async (event: any) => {
  const req = camelToSnakeCase(JSON.parse(event.body || '{}'));
  const { user_id, ...prefs } = req;
  const startTime = Date.now();
  const sessionId = uuidv4();
  
  console.log('\n=== üéØ Ïù¥ÏÉÅÌòï Ï†ÄÏû• API Ìò∏Ï∂úÎê® ===');
  console.log('ÏãúÍ∞Ñ:', new Date().toISOString());
  console.log('üåê ÏöîÏ≤≠ Í≤ΩÎ°ú:', event.requestContext?.http?.path || 'unknown');
  console.log('üìã ÏöîÏ≤≠ Î©îÏÑúÎìú:', event.requestContext?.http?.method || 'unknown');
  console.log('ÏõêÎ≥∏ Event body:');
  console.log('Event Ï†ÑÏ≤¥:', JSON.stringify(event, null, 2));
  
  try {
    console.log('‚úÖ ÌååÏã±Îêú Îç∞Ïù¥ÌÑ∞:');
    console.log('   - userId:', user_id);
    console.log('   - userId ÌÉÄÏûÖ:', typeof user_id);
    console.log('   - preferences:', JSON.stringify(prefs, null, 2));
    console.log('   - preferences ÌÇ§Îì§:', Object.keys(prefs));
    
    if (!user_id) {
      console.error('‚ùå userIdÍ∞Ä ÏóÜÏäµÎãàÎã§');
      return { 
        statusCode: 400, 
        body: JSON.stringify({ error: 'Missing userId' }) 
      };
    }
    
    const preferences: UserPreferences[] = readJson(preferencesPath);
    console.log('üìÅ Í∏∞Ï°¥ preferences.json ÎÇ¥Ïö©:', preferences);
    
    const idx = preferences.findIndex(p => p.user_id === user_id);
    if (idx >= 0) {
      preferences[idx] = { user_id, ...prefs };
      console.log('üîÑ Í∏∞Ï°¥ ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ (Ïù∏Îç±Ïä§:', idx, ')');
    } else {
      preferences.push({ user_id, ...prefs });
      console.log('‚ûï ÏÉà ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä');
    }
    
    writeJson(preferencesPath, preferences);
    console.log('üíæ preferences.json Ï†ÄÏû• ÏôÑÎ£å');
    console.log('üìÅ Ï†ÄÏû•Îêú preferences.json ÎÇ¥Ïö©:', preferences);

    // users.jsonÏùò has_preferences trueÎ°ú Î≥ÄÍ≤Ω
    const users = readJson(usersPath);
    console.log('üë• Í∏∞Ï°¥ users.json ÎÇ¥Ïö©:', users);
    
    const userIdx = users.findIndex((u: any) => u.user_id === user_id);
    let email = '';
    if (userIdx >= 0) {
      users[userIdx].has_preferences = true;
      email = users[userIdx].email;
      writeJson(usersPath, users);
      console.log('‚úÖ users.json ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å - has_preferences: true');
      console.log('‚úÖ ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏÇ¨Ïö©Ïûê:', users[userIdx]);
    } else {
      console.log('‚ùå ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå:', user_id);
    }

    const executionTime = Date.now() - startTime;
    const responseBody = JSON.stringify({ ok: true });

    await appendLog({
      type: 'preferences_save',
      userId: user_id,
      email,
      ip: event?.requestContext?.identity?.sourceIp || '',
      result: 'success',
      message: 'Ïù¥ÏÉÅÌòï Ï†ÄÏû• ÏÑ±Í≥µ',
      detail: { 
        preferencesCount: preferences.length,
        updatedUserIndex: userIdx,
        hasPreferencesUpdated: userIdx >= 0,
        preferencesData: prefs
      },
      requestMethod: event.requestContext?.http?.method || 'POST',
      requestPath: event.requestContext?.http?.path || '/user-preferences',
      requestBody: event.body || '',
      responseStatus: 200,
      responseBody,
      executionTime,
      sessionId,
      action: 'Ïù¥ÏÉÅÌòï Ï†ÄÏû•',
      screen: 'PreferenceSetupScreen',
      component: 'saveUserPreferences'
    });

    console.log('üéâ === Ïù¥ÏÉÅÌòï Ï†ÄÏû• ÏôÑÎ£å ===\n');
    return { statusCode: 200, body: responseBody };
  } catch (error: any) {
    const executionTime = Date.now() - startTime;
    const errorMessage = `Ïù¥ÏÉÅÌòï Ï†ÄÏû• Ïã§Ìå®: ${error.message}`;
    const responseBody = JSON.stringify({ 
      error: 'Ïù¥ÏÉÅÌòï Ï†ÄÏû• Ïã§Ìå®', 
      message: error.message 
    });

    console.error('Ïù¥ÏÉÅÌòï Ï†ÄÏû• Ï§ë ÏóêÎü¨ Î∞úÏÉù:', error);
    console.error('ÏóêÎü¨ Ïä§ÌÉù:', error.stack);

    await appendLog({
      type: 'preferences_save',
      userId: '',
      email: '',
      ip: event?.requestContext?.identity?.sourceIp || '',
      result: 'fail',
      message: errorMessage,
      detail: { 
        errorType: error.constructor.name,
        errorMessage: error.message
      },
      requestMethod: event.requestContext?.http?.method || 'POST',
      requestPath: event.requestContext?.http?.path || '/user-preferences',
      requestBody: event.body || '',
      responseStatus: 500,
      responseBody,
      errorStack: error.stack,
      executionTime,
      sessionId,
      action: 'Ïù¥ÏÉÅÌòï Ï†ÄÏû•',
      screen: 'PreferenceSetupScreen',
      component: 'saveUserPreferences'
    });

    return { 
      statusCode: 500, 
      body: responseBody
    };
  }
};

// ÌîÑÎ°úÌïÑ Ï°∞Ìöå
function getBaseUrl(event: any) {
  const host = event.headers?.['host'] || event.requestContext?.domainName || 'localhost:3000';
  const protocol = event.headers?.['x-forwarded-proto'] || 'http';
  return `${protocol}://${host}`;
}

export const getProfile = async (event: any) => {
  const { userId } = event.pathParameters || {};
  console.log('ÌîÑÎ°úÌïÑ Ï°∞Ìöå ÏöîÏ≤≠:', { userId, path: event.requestContext?.http?.path });
  const profiles: UserProfile[] = readJson(profilesPath);
  const users: User[] = readJson(usersPath);
  const profile = profiles.find(p => p.user_id === userId);
  const user = users.find(u => u.user_id === userId);
  if (profile) {
    const baseUrl = getBaseUrl(event);
    // photosÏùò Í∞Å Í≤ΩÎ°ú ÏïûÏóê baseUrl Î∂ôÏù¥Í∏∞
    const transformedProfile = snakeToCamelCase({
      ...profile,
      points: user?.points ?? 0,
      photos: (profile.photos || []).map((url: string) =>
        url && url.startsWith('/files/') ? `${baseUrl}${url}` : url
      ),
    });
    const responseBody = JSON.stringify(transformedProfile);
    await appendLog({
      type: 'profile_get',
      userId: userId,
      result: 'success',
      message: 'ÌîÑÎ°úÌïÑ Ï°∞Ìöå ÏÑ±Í≥µ',
      detail: { userId, profile },
      requestMethod: event.requestContext?.http?.method || 'GET',
      requestPath: event.requestContext?.http?.path || `/profile/${userId}`,
      responseStatus: 200,
      responseBody,
      action: 'ÌîÑÎ°úÌïÑ Ï°∞Ìöå',
      screen: 'ProfileScreen',
      component: 'getProfile'
    });
    return { statusCode: 200, body: responseBody };
  }
  await appendLog({
    type: 'profile_get',
    userId: userId,
    result: 'fail',
    message: 'ÌîÑÎ°úÌïÑ Ï°∞Ìöå Ïã§Ìå®',
    detail: { userId },
    requestMethod: event.requestContext?.http?.method || 'GET',
    requestPath: event.requestContext?.http?.path || `/profile/${userId}`,
    responseStatus: 404,
    responseBody: JSON.stringify({ error: 'Profile not found', userId }),
    action: 'ÌîÑÎ°úÌïÑ Ï°∞Ìöå',
    screen: 'ProfileScreen',
    component: 'getProfile'
  });
  return { statusCode: 404, body: JSON.stringify({ error: 'Profile not found', userId }) };
};

// Ïù¥ÏÉÅÌòï Ï°∞Ìöå
export const getUserPreferences = async (event: any) => {
  const { userId } = event.pathParameters || {};
  const preferences: UserPreferences[] = readJson(preferencesPath);
  const pref = preferences.find(p => p.user_id === userId);
  if (pref) {
    return { statusCode: 200, body: JSON.stringify(snakeToCamelCase(pref)) };
  }
  return { statusCode: 404, body: JSON.stringify({ error: 'Preferences not found' }) };
};

// ÏÜåÍ∞úÌåÖ Ïã†Ï≤≠
export const requestMatching = async (event: any) => {
  const { userId } = JSON.parse(event.body || '{}');
  const users: User[] = readJson(usersPath);
  const user = users.find(u => u.user_id === userId);
  
  if (!user) {
    return { statusCode: 404, body: JSON.stringify({ error: 'User not found' }) };
  }
  
  if (user.points < 100) {
    return { statusCode: 400, body: JSON.stringify({ error: 'Insufficient points' }) };
  }
  
  // Ìè¨Ïù∏Ìä∏ Ï∞®Í∞ê
  user.points -= 100;
  writeJson(usersPath, users);
  
  // MatchingRequests ÌÖåÏù¥Î∏îÏóê Í∏∞Î°ù ÏÉùÏÑ±
  const matchingRequestsPath = path.join(__dirname, 'data/matching-requests.json');
  const matchingRequests = fs.existsSync(matchingRequestsPath) ? readJson(matchingRequestsPath) : [];
  
  const newRequest = {
    match_id: `match-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    requester_id: userId,
    status: 'waiting',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    is_manual: false,
    date_choices: { dates: [], locations: [] },
    photo_visible_at: null
  };
  
  matchingRequests.push(newRequest);
  writeJson(matchingRequestsPath, matchingRequests);
  
  await appendLog({
    type: 'matching_request',
    userId,
    email: user.email,
    ip: event?.requestContext?.identity?.sourceIp || '',
    result: 'success',
    detail: { match_id: newRequest.match_id, points_deducted: 100 },
  });
  
  return { statusCode: 200, body: JSON.stringify({ match_id: newRequest.match_id }) };
};

// Îß§Ïπ≠ ÏöîÏ≤≠ Î™©Î°ù Ï°∞Ìöå (Í¥ÄÎ¶¨ÏûêÏö©)
export const getMatchingRequests = async (event: any) => {
  const matchingRequestsPath = path.join(__dirname, 'data/matching-requests.json');
  const matchingRequests = fs.existsSync(matchingRequestsPath) ? readJson(matchingRequestsPath) : [];
  
  const waitingRequests = matchingRequests.filter((req: any) => req.status === 'waiting');
  
  return { statusCode: 200, body: JSON.stringify({ requests: waitingRequests }) };
};

// Îß§Ïπ≠ ÌôïÏ†ï
export const confirmMatching = async (event: any) => {
  const { match_id, user_a_id, user_b_id } = JSON.parse(event.body || '{}');
  
  // MatchingRequests ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
  const matchingRequestsPath = path.join(__dirname, 'data/matching-requests.json');
  const matchingRequests = fs.existsSync(matchingRequestsPath) ? readJson(matchingRequestsPath) : [];
  const requestIndex = matchingRequests.findIndex((req: any) => req.match_id === match_id);
  
  if (requestIndex >= 0) {
    matchingRequests[requestIndex].status = 'confirmed';
    writeJson(matchingRequestsPath, matchingRequests);
  }
  
  // MatchPairs ÌÖåÏù¥Î∏îÏóê Í∏∞Î°ù ÏÉùÏÑ±
  const matchPairsPath = path.join(__dirname, 'data/match-pairs.json');
  const matchPairs = fs.existsSync(matchPairsPath) ? readJson(matchPairsPath) : [];
  
  const newMatch = {
    match_id,
    user_a_id,
    user_b_id,
    user_a_choices: { dates: [], locations: [] },
    user_b_choices: { dates: [], locations: [] },
    final_date: null,
    final_location: null
  };
  
  matchPairs.push(newMatch);
  writeJson(matchPairsPath, matchPairs);
  
  await appendLog({
    type: 'matching_confirmed',
    userId: user_a_id,
    result: 'success',
    detail: { match_id, user_a_id, user_b_id },
  });
  
  return { statusCode: 200, body: JSON.stringify({ match_id }) };
};

// ÏùºÏ†ï Ï†úÏ∂ú Î∞è Ï°∞Ïú® Ïã§Ìå®/Ïû¨Îß§Ïπ≠ Î°úÏßÅ Ï∂îÍ∞Ä
export const submitChoices = async (event: any) => {
  const { match_id, user_id, dates, locations, acceptOtherSchedule } = JSON.parse(event.body || '{}');

  const matchPairsPath = path.join(__dirname, 'data/match-pairs.json');
  const matchPairs = fs.existsSync(matchPairsPath) ? readJson(matchPairsPath) : [];
  const matchIndex = matchPairs.findIndex((match: any) => match.match_id === match_id || match.match_a_id === match_id || match.match_b_id === match_id);

  const now = new Date().toISOString();

  if (matchIndex >= 0) {
    const match = matchPairs[matchIndex];
    // ÏùºÏ†ï Ï†úÏ∂ú
    let changed = false;
    if (match.user_a_id === user_id) {
      match.user_a_choices = { dates, locations };
      changed = true;
    } else if (match.user_b_id === user_id) {
      match.user_b_choices = { dates, locations };
      changed = true;
    }
    // ÏñëÏ™Ω Î™®Îëê Ï†úÏ∂úÌñàÎäîÏßÄ ÌôïÏù∏
    if (match.user_a_choices?.dates?.length && match.user_b_choices?.dates?.length) {
      // Í≤πÏπòÎäî ÎÇ†Ïßú/Ïû•ÏÜå Ï∞æÍ∏∞
      const commonDates = match.user_a_choices.dates.filter((d: string) => match.user_b_choices.dates.includes(d));
      const commonLocations = match.user_a_choices.locations.filter((l: string) => match.user_b_choices.locations.includes(l));
      if (commonDates.length && commonLocations.length) {
        // ÏùºÏ†ï ÌôïÏ†ï
        match.schedule_date = commonDates[0];
        match.date_location = commonLocations[0];
        match.status = 'scheduled';
        changed = true;
      } else {
        // ÏùºÏ†ï Ï°∞Ïú® Ïã§Ìå®
        match.status = 'failed';
        changed = true;
      }
    }
    // ÏÉÅÎåÄÎ∞© ÏùºÏ†ïÏóê ÎßûÏ∂îÍ∏∞(acceptOtherSchedule)
    if (acceptOtherSchedule) {
      // ÏÉÅÎåÄÎ∞©Ïù¥ Î®ºÏ†Ä Ï†úÏ∂úÌïú ÏùºÏ†ïÏúºÎ°ú ÌôïÏ†ï
      const otherChoices = match.user_a_id === user_id ? match.user_b_choices : match.user_a_choices;
      match.schedule_date = otherChoices.dates[0];
      match.date_location = otherChoices.locations[0];
      match.status = 'scheduled';
      changed = true;
    }
    if (changed) {
      match.updated_at = now;
    }
    writeJson(matchPairsPath, matchPairs);

    // matching-requests ÏÉÅÌÉúÎèÑ Í∞ôÏù¥ Î≥ÄÍ≤Ω
    const matchingRequestsPath = path.join(__dirname, 'data/matching-requests.json');
    const matchingRequests = fs.existsSync(matchingRequestsPath) ? readJson(matchingRequestsPath) : [];
    // match_a_id, match_b_idÎ°ú Í∞ÅÍ∞Å Ï∞æÏïÑÏÑú ÏÉÅÌÉú Î≥ÄÍ≤Ω
    [match.match_a_id, match.match_b_id].forEach((mid: string) => {
      const reqIdx = matchingRequests.findIndex((req: any) => req.match_id === mid);
      if (reqIdx >= 0) {
        // ÏùºÏ†ï Ï†úÏ∂úÌïú Ï™ΩÏùÄ confirm, ÏµúÏ¢Ö ÌôïÏ†ï Ïãú scheduled
        if (match.status === 'scheduled') {
          matchingRequests[reqIdx].status = 'scheduled';
        } else if (user_id && mid === match_id) {
          matchingRequests[reqIdx].status = 'confirmed';
        }
        // date_choices Ï†ÄÏû• (ÏùºÏ†ï Ï†úÏ∂úÌïú Ï™ΩÎßå)
        if (user_id && mid === match_id) {
          matchingRequests[reqIdx].date_choices = { dates, locations };
        }
        matchingRequests[reqIdx].updated_at = now;
      }
    });
    writeJson(matchingRequestsPath, matchingRequests);
  }
  await appendLog({
    type: 'choices_submitted',
    userId: user_id,
    result: 'success',
    detail: { match_id, dates, locations },
  });
  return { statusCode: 200, body: JSON.stringify({ ok: true }) };
};

// Î¶¨Î∑∞ Ï†ÄÏû•
export const saveReview = async (event: any) => {
  const { match_id, reviewer_id, target_id, rating, want_to_meet_again, tags, comment } = JSON.parse(event.body || '{}');
  
  const reviewsPath = path.join(__dirname, 'data/reviews.json');
  const reviews = fs.existsSync(reviewsPath) ? readJson(reviewsPath) : [];
  
  const newReview = {
    review_id: `review-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    match_id,
    reviewer_id,
    target_id,
    rating,
    want_to_meet_again,
    tags,
    comment,
    created_at: new Date().toISOString()
  };
  
  reviews.push(newReview);
  writeJson(reviewsPath, reviews);
  
  // ReviewStats ÏóÖÎç∞Ïù¥Ìä∏
  const reviewStatsPath = path.join(__dirname, 'data/review-stats.json');
  const reviewStats = fs.existsSync(reviewStatsPath) ? readJson(reviewStatsPath) : [];
  
  let targetStats = reviewStats.find((stats: any) => stats.user_id === target_id);
  if (!targetStats) {
    targetStats = {
      user_id: target_id,
      avg_appearance: 0,
      avg_conversation: 0,
      avg_manners: 0,
      avg_honesty: 0,
      total_reviews: 0,
      positive_tags: []
    };
    reviewStats.push(targetStats);
  }
  
  // ÌèâÍ∑† Í≥ÑÏÇ∞
  targetStats.total_reviews += 1;
  targetStats.avg_appearance = (targetStats.avg_appearance * (targetStats.total_reviews - 1) + rating.appearance) / targetStats.total_reviews;
  targetStats.avg_conversation = (targetStats.avg_conversation * (targetStats.total_reviews - 1) + rating.conversation) / targetStats.total_reviews;
  targetStats.avg_manners = (targetStats.avg_manners * (targetStats.total_reviews - 1) + rating.manners) / targetStats.total_reviews;
  targetStats.avg_honesty = (targetStats.avg_honesty * (targetStats.total_reviews - 1) + rating.honesty) / targetStats.total_reviews;
  
  // Í∏çÏ†ïÏ†Å ÌÉúÍ∑∏ Ï∂îÍ∞Ä
  if (tags && tags.length > 0) {
    targetStats.positive_tags = [...new Set([...targetStats.positive_tags, ...tags])];
  }
  
  writeJson(reviewStatsPath, reviewStats);
  
  await appendLog({
    type: 'review_saved',
    userId: reviewer_id,
    result: 'success',
    detail: { review_id: newReview.review_id, target_id, rating },
  });
  
  return { statusCode: 200, body: JSON.stringify({ review_id: newReview.review_id }) };
};

// Ìè¨Ïù∏Ìä∏ Ï∂©Ï†Ñ
export const chargePoints = async (event: any) => {
  const { userId, amount, type } = JSON.parse(event.body || '{}');
  
  const users: User[] = readJson(usersPath);
  const userIndex = users.findIndex(u => u.user_id === userId);
  
  if (userIndex >= 0) {
    users[userIndex].points += amount;
    writeJson(usersPath, users);
    
    // PointsHistory Í∏∞Î°ù
    const pointsHistoryPath = path.join(__dirname, 'data/points-history.json');
    const pointsHistory = fs.existsSync(pointsHistoryPath) ? readJson(pointsHistoryPath) : [];
    
    const newHistory = {
      user_id: userId,
      timestamp: new Date().toISOString(),
      type,
      points: amount,
      description: `${type} Ìè¨Ïù∏Ìä∏ Ï†ÅÎ¶Ω`
    };
    
    pointsHistory.push(newHistory);
    writeJson(pointsHistoryPath, pointsHistory);
    
    await appendLog({
      type: 'points_charged',
      userId,
      result: 'success',
      detail: { amount, type, new_balance: users[userIndex].points },
    });
    
    return { statusCode: 200, body: JSON.stringify({ points: users[userIndex].points }) };
  }
  
  return { statusCode: 404, body: JSON.stringify({ error: 'User not found' }) };
};

// ÏÇ¨Ïö©Ïûê ÏÉÅÌÉú Î≥ÄÍ≤Ω (Í¥ÄÎ¶¨ÏûêÏö©)
export const updateUserStatus = async (event: any) => {
  const { userId, new_status, reason, updated_by } = JSON.parse(event.body || '{}');
  
  const users: User[] = readJson(usersPath);
  const userIndex = users.findIndex(u => u.user_id === userId);
  
  if (userIndex >= 0) {
    const oldStatus = users[userIndex].status;
    users[userIndex].status = new_status;
    writeJson(usersPath, users);
    
    // UserStatusHistory Í∏∞Î°ù
    const statusHistoryPath = path.join(__dirname, 'data/user-status-history.json');
    const statusHistory = fs.existsSync(statusHistoryPath) ? readJson(statusHistoryPath) : [];
    
    const newHistory = {
      user_id: userId,
      timestamp: new Date().toISOString(),
      from_status: oldStatus,
      to_status: new_status,
      reason,
      updated_by
    };
    
    statusHistory.push(newHistory);
    writeJson(statusHistoryPath, statusHistory);
    
    await appendLog({
      type: 'user_status_updated',
      userId,
      result: 'success',
      detail: { from_status: oldStatus, to_status: new_status, reason },
      action: 'ÏÇ¨Ïö©Ïûê ÏÉÅÌÉú Î≥ÄÍ≤Ω',
      screen: 'AdminScreen',
      component: 'user_status'
    });
    
    return { statusCode: 200, body: JSON.stringify({ status: new_status }) };
  }
  
  return { statusCode: 404, body: JSON.stringify({ error: 'User not found' }) };
};

// ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï°∞Ìöå
export const getUser = async (event: any) => {
  const { userId } = event.pathParameters || {};
  const users: User[] = readJson(usersPath);
  const user = users.find(u => u.user_id === userId);
  if (user) {
    return { statusCode: 200, body: JSON.stringify(snakeToCamelCase(user)) };
  }
  return { statusCode: 404, body: JSON.stringify({ error: 'User not found', userId }) };
};

// Ïπ¥Îìú(ÏÜåÍ∞úÌåÖ ÏÉÅÎåÄ) Î™©Î°ù Ï°∞Ìöå
export const getCards = async (event: any) => {
  const userId = event.queryStringParameters?.userId || event.headers?.userid;
  const search = event.queryStringParameters?.search || ''; // Í≤ÄÏÉâÏñ¥
  const status = event.queryStringParameters?.status || 'all'; // ÏÉÅÌÉú ÌïÑÌÑ∞
  const page = parseInt(event.queryStringParameters?.page || '1', 10);
  const pageSize = parseInt(event.queryStringParameters?.pageSize || '10', 10);
  
  if (!userId) {
    return { statusCode: 400, body: JSON.stringify({ error: 'userId required' }) };
  }
  
  const matchPairs = readJson(matchPairsPath);
  const profiles = readJson(profilesPath);
  const myMatches = matchPairs.filter((m: any) => m.user_a_id === userId || m.user_b_id === userId);
  
  function calcAge(birthDate: any): number | null {
    if (!birthDate) return null;
    let year;
    if (typeof birthDate === 'string') {
      year = parseInt(birthDate.split('-')[0], 10);
    } else if (typeof birthDate === 'object' && birthDate.year) {
      year = birthDate.year;
    }
    if (!year) return null;
    const now = new Date();
    return now.getFullYear() - year;
  }

  let cards = myMatches.map((m: any) => {
    const otherUserId = m.user_a_id === userId ? m.user_b_id : m.user_a_id;
    const profile = profiles.find((p: any) => p.user_id === otherUserId);
    if (!profile) {
      return null;
    }
    return {
      matchId: m.match_id,
      userId: otherUserId,
      isDeleted: false,
      name: profile.name || '',
      job: profile.job || '',
      region: profile.region?.region || '',
      district: profile.region?.district || '',
      photoUrl: profile.photos?.[0] || null,
      age: calcAge(profile.birth_date),
      date: m.final_date || null,
      status: m.final_date ? 'revealed' : 'pending',
    };
  }).filter(Boolean);

  // Í≤ÄÏÉâÏñ¥ ÌïÑÌÑ∞ÎßÅ
  if (search.trim()) {
    cards = cards.filter((card: any) => 
      card.name?.toLowerCase().includes(search.toLowerCase()) ||
      card.job?.toLowerCase().includes(search.toLowerCase()) ||
      card.region?.toLowerCase().includes(search.toLowerCase()) ||
      card.district?.toLowerCase().includes(search.toLowerCase())
    );
  }

  // ÏÉÅÌÉúÎ≥Ñ ÌïÑÌÑ∞ÎßÅ
  if (status !== 'all') {
    cards = cards.filter((card: any) => card.status === status);
  }

  // ÌéòÏù¥Ïßï Ï≤òÎ¶¨ (ÌïÑÌÑ∞ÎßÅ ÌõÑ)
  const total = cards.length;
  const start = (page - 1) * pageSize;
  const paged = cards.slice(start, start + pageSize);
  
  await appendLog({
    type: 'get_cards',
    userId,
    requestMethod: event.requestContext?.http?.method || 'GET',
    requestPath: event.requestContext?.http?.path || '/cards',
    result: 'success',
    detail: { 
      page, 
      pageSize, 
      total, 
      returned: paged.length,
      search: search || null,
      status: status !== 'all' ? status : null
    },
    action: 'Ïπ¥ÎìúÌï® Ï°∞Ìöå',
    screen: 'CardsScreen',
    component: 'cards_list'
  });
  
  return { 
    statusCode: 200, 
    body: JSON.stringify({
      cards: paged.map(snakeToCamelCase),
      pagination: {
        page,
        pageSize,
        total,
        totalPages: Math.ceil(total / pageSize)
      }
    })
  };
};

// Î¶¨Î∑∞ Î™©Î°ù Ï°∞Ìöå
export const getReviews = async (event: any) => {
  const userId = event.queryStringParameters?.userId || event.headers?.userid;
  const page = parseInt(event.queryStringParameters?.page || '1', 10);
  const pageSize = parseInt(event.queryStringParameters?.pageSize || '10', 10);
  if (!userId) {
    return { statusCode: 400, body: JSON.stringify({ error: 'userId required' }) };
  }
  const reviews = readJson(reviewsPath);
  const myReviews = reviews.filter((r: any) => r.target_id === userId);
  // ÌéòÏù¥Ïßï Ï≤òÎ¶¨
  const start = (page - 1) * pageSize;
  const paged = myReviews.slice(start, start + pageSize);
  // Î°úÍ∑∏ Í∏∞Î°ù
  await appendLog({
    type: 'get_reviews',
    userId,
    requestMethod: event.requestContext?.http?.method || 'GET',
    requestPath: event.requestContext?.http?.path || '/reviews',
    result: 'success',
    detail: { page, pageSize, total: myReviews.length, returned: paged.length },
    action: 'ÌõÑÍ∏∞ Ï°∞Ìöå',
    screen: 'ReviewsScreen',
    component: 'reviews_list'
  });
  return { statusCode: 200, body: JSON.stringify(paged.map(snakeToCamelCase)) };
};

// Ìôà(Î©îÏù∏) ÌîÑÎ°úÌïÑ Ïπ¥Îìú 1Í±¥ Ï°∞Ìöå
export const getMainCard = async (event: any) => {
  const userId = event.queryStringParameters?.userId || event.headers?.userid;
  if (!userId) {
    return { statusCode: 400, body: JSON.stringify({ error: 'userId required' }) };
  }
  // matching-requestsÏóêÏÑú Ïã†Ï≤≠ Í∏∞Î°ù Ï°∞Ìöå
  const matchingRequestsPath = path.join(__dirname, 'data/matching-requests.json');
  const matchingRequests = fs.existsSync(matchingRequestsPath) ? readJson(matchingRequestsPath) : [];
  const myRequest = matchingRequests.find((req: any) => req.requester_id === userId);
  let status = null;
  if (myRequest) {
    status = myRequest.status; // waiting, matching, confirmed, scheduled Îì±
  }
  // mainCard ÏóÜÏù¥ statusÎßå Î∞òÌôò
  await appendLog({ 
    type: 'get_main_card', 
    userId, 
    result: 'success', 
    detail: { status },
    action: 'Î©îÏù∏Ïπ¥Îìú Ï°∞Ìöå',
    screen: 'MainScreen',
    component: 'main_card'
  });
  return { statusCode: 200, body: JSON.stringify({ matchingStatus: status }) };
};

// Ïπ¥Îìú ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï°∞Ìöå
export const getCardDetail = async (event: any) => {
  const userId = event.pathParameters?.userId;
  if (!userId) {
    return { statusCode: 400, body: JSON.stringify({ error: 'userId required' }) };
  }
  
  const profiles = readJson(profilesPath);
  const profile = profiles.find((p: any) => p.user_id === userId);
  
  if (!profile) {
    await appendLog({
      type: 'get_card_detail',
      userId: '',
      result: 'fail',
      message: 'Profile not found',
      detail: { requestedUserId: userId },
      action: 'Ïπ¥Îìú ÏÉÅÏÑ∏ Ï°∞Ìöå',
      screen: 'UserDetailScreen',
      component: 'card_detail'
    });
    return { statusCode: 404, body: JSON.stringify({ error: 'Profile not found' }) };
  }
  
  await appendLog({
    type: 'get_card_detail',
    userId: userId,
    result: 'success',
    detail: { profileFound: true },
    action: 'Ïπ¥Îìú ÏÉÅÏÑ∏ Ï°∞Ìöå',
    screen: 'UserDetailScreen',
    component: 'card_detail'
  });
  
  return { statusCode: 200, body: JSON.stringify(snakeToCamelCase(profile)) };
};

// Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú
export const uploadImage = async (event: any) => {
  const { userId, imageData, fileName } = JSON.parse(event.body || '{}');
  
  if (!userId || !imageData) {
    return { statusCode: 400, body: JSON.stringify({ error: 'userId and imageData required' }) };
  }

  try {
    // base64 Îç∞Ïù¥ÌÑ∞ÏóêÏÑú Ïã§Ï†ú Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
    const base64Data = imageData.replace(/^data:image\/[a-z]+;base64,/, '');
    const buffer = Buffer.from(base64Data, 'base64');

    // ÌååÏùº Í≤ÄÏ¶ù
    if (!validateFileSize(buffer)) {
      return { statusCode: 400, body: JSON.stringify({ error: 'File size exceeds 10MB limit' }) };
    }

    if (!validateImageFormat(fileName || 'image.jpg')) {
      return { statusCode: 400, body: JSON.stringify({ error: 'Invalid image format' }) };
    }

    // AWS S3 Íµ¨Ï°∞Î•º Í≥†Î†§Ìïú Í≤ΩÎ°ú ÏÉùÏÑ±
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    
    // S3 Íµ¨Ï°∞: images/profile/{year}/{month}/{day}/{userId}/
    const s3Path = generateS3Path(userId, '', 'profile');
    const localPath = `${year}/${month}/${day}/${userId}`;
    const filesDir = path.join(__dirname, 'files', localPath);
    
    // ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
    if (!fs.existsSync(filesDir)) {
      fs.mkdirSync(filesDir, { recursive: true });
    }

    // ÌååÏùºÎ™Ö ÏÉùÏÑ± (ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ + ÏõêÎ≥∏ ÌôïÏû•Ïûê)
    const timestamp = Date.now();
    const extension = fileName ? fileName.split('.').pop()?.toLowerCase() : 'jpg';
    const savedFileName = `${timestamp}.${extension}`;
    const filePath = path.join(filesDir, savedFileName);

    // ÌååÏùº Ï†ÄÏû•
    fs.writeFileSync(filePath, buffer);

    // URL ÏÉùÏÑ± (S3 Íµ¨Ï°∞Î•º Í≥†Î†§Ìïú Í≤ΩÎ°ú)
    const imageUrl = `/files/${localPath}/${savedFileName}`;
    const s3FullPath = `${s3Path}/${savedFileName}`;
    const baseUrl = getBaseUrl(event);

    await appendLog({
      type: 'image_upload',
      userId,
      result: 'success',
      detail: { 
        fileName: savedFileName, 
        localPath,
        s3Path: s3FullPath,
        fileSize: buffer.length,
        fullPath: imageUrl
      },
      action: 'Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú',
      screen: 'ProfileEditScreen',
      component: 'image_upload'
    });

    return { 
      statusCode: 200, 
      body: JSON.stringify({ 
        imageUrl: `${baseUrl}${imageUrl}`,
        fileName: savedFileName,
        localPath,
        s3Path: s3FullPath,
        fullPath: imageUrl
      }) 
    };
  } catch (error: any) {
    console.error('Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏóêÎü¨:', error);
    
    await appendLog({
      type: 'image_upload',
      userId,
      result: 'fail',
      message: error.message,
      detail: { error: error.message },
      action: 'Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú',
      screen: 'ProfileEditScreen',
      component: 'image_upload'
    });

    return { 
      statusCode: 500, 
      body: JSON.stringify({ error: 'Image upload failed' }) 
    };
  }
};

// Ï†ïÏ†Å ÌååÏùº ÏÑúÎπô (Í∞úÎ∞úÏö©)
export const serveFile = async (event: any) => {
  const { year, month, day, userId, fileName } = event.pathParameters || {};
  
  if (!year || !month || !day || !userId || !fileName) {
    return { statusCode: 404, body: 'File not found' };
  }

  try {
    // Íµ¨Ï°∞ÌôîÎêú Í≤ΩÎ°úÎ°ú ÌååÏùº Ï∞æÍ∏∞
    const filePath = path.join(__dirname, 'files', year, month, day, userId, fileName);
    
    if (!fs.existsSync(filePath)) {
      return { statusCode: 404, body: 'File not found' };
    }

    const fileContent = fs.readFileSync(filePath);
    const contentType = getContentType(fileName);

    return {
      statusCode: 200,
      headers: {
        'Content-Type': contentType,
        'Cache-Control': 'public, max-age=31536000'
      },
      body: fileContent.toString('base64'),
      isBase64Encoded: true
    };
  } catch (error) {
    console.error('ÌååÏùº ÏÑúÎπô ÏóêÎü¨:', error);
    return { statusCode: 500, body: 'Internal server error' };
  }
};

// ÌååÏùº ÌôïÏû•ÏûêÏóê Îî∞Î•∏ Content-Type Î∞òÌôò
function getContentType(fileName: string): string {
  const extension = fileName.split('.').pop()?.toLowerCase();
  switch (extension) {
    case 'jpg':
    case 'jpeg':
      return 'image/jpeg';
    case 'png':
      return 'image/png';
    case 'gif':
      return 'image/gif';
    case 'webp':
      return 'image/webp';
    default:
      return 'application/octet-stream';
  }
}

// Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò (Í∞úÎ∞úÏö©)
export const migrateImages = async (event: any) => {
  try {
    const profiles = readJson(profilesPath);
    const migratedCount = { success: 0, failed: 0 };
    
    for (const profile of profiles) {
      if (profile.photos && Array.isArray(profile.photos)) {
        const newPhotos = [];
        
        for (const photoUrl of profile.photos) {
          // Í∏∞Ï°¥ Î°úÏª¨ ÌååÏùº Í≤ΩÎ°úÏù∏ÏßÄ ÌôïÏù∏
          if (photoUrl && photoUrl.startsWith('file:///')) {
            try {
              // Ïã§Ï†ú ÌååÏùº Í≤ΩÎ°ú Ï∂îÏ∂ú
              const localPath = photoUrl.replace('file://', '');
              if (!fs.existsSync(localPath)) {
                // ÌååÏùºÏù¥ ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ Í≤ΩÎ°ú Ïú†ÏßÄ
                newPhotos.push(photoUrl);
                migratedCount.failed++;
                continue;
              }
              // ÏÉà Í≤ΩÎ°ú ÏÉùÏÑ±
              const now = new Date();
              const year = now.getFullYear();
              const month = String(now.getMonth() + 1).padStart(2, '0');
              const day = String(now.getDate()).padStart(2, '0');
              const timestamp = Date.now();
              const ext = localPath.split('.').pop() || 'jpg';
              const newFileName = `${timestamp}.${ext}`;
              const newDir = path.join(__dirname, 'files', `${year}`, `${month}`, `${day}`, profile.user_id);
              if (!fs.existsSync(newDir)) {
                fs.mkdirSync(newDir, { recursive: true });
              }
              const newFilePath = path.join(newDir, newFileName);
              fs.copyFileSync(localPath, newFilePath);
              const newPhotoUrl = `/files/${year}/${month}/${day}/${profile.user_id}/${newFileName}`;
              newPhotos.push(newPhotoUrl);
              migratedCount.success++;
            } catch (error) {
              console.error(`Ïù¥ÎØ∏ÏßÄ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìå®: ${photoUrl}`, error);
              migratedCount.failed++;
              // Ïã§Ìå® Ïãú Í∏∞Ï°¥ URL Ïú†ÏßÄ
              newPhotos.push(photoUrl);
            }
          } else {
            // Ïù¥ÎØ∏ Ïò¨Î∞îÎ•∏ ÌòïÏãùÏù¥Í±∞ÎÇò Ïô∏Î∂Ä URLÏù∏ Í≤ΩÏö∞ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
            newPhotos.push(photoUrl);
          }
        }
        // ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏
        profile.photos = newPhotos;
      }
    }
    // ÏóÖÎç∞Ïù¥Ìä∏Îêú ÌîÑÎ°úÌïÑ Ï†ÄÏû•
    writeJson(profilesPath, profiles);
    await appendLog({
      type: 'image_migration',
      userId: '',
      result: 'success',
      detail: { 
        migratedCount,
        totalProfiles: profiles.length
      },
      action: 'Ïù¥ÎØ∏ÏßÄ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò',
      screen: 'AdminScreen',
      component: 'image_migration'
    });
    return { 
      statusCode: 200, 
      body: JSON.stringify({ 
        message: 'Image migration completed',
        migratedCount,
        totalProfiles: profiles.length
      }) 
    };
  } catch (error: any) {
    console.error('Ïù¥ÎØ∏ÏßÄ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏóêÎü¨:', error);
    await appendLog({
      type: 'image_migration',
      userId: '',
      result: 'fail',
      message: error.message,
      detail: { error: error.message },
      action: 'Ïù¥ÎØ∏ÏßÄ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò',
      screen: 'AdminScreen',
      component: 'image_migration'
    });
    return { 
      statusCode: 500, 
      body: JSON.stringify({ error: 'Image migration failed' }) 
    };
  }
};

// AWS S3 Íµ¨Ï°∞Î•º Í≥†Î†§Ìïú ÌååÏùº Í≤ΩÎ°ú ÏÉùÏÑ± Ìï®Ïàò
function generateS3Path(userId: string, fileName: string, type: 'profile' | 'temp' = 'profile'): string {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  
  // S3 Íµ¨Ï°∞: {bucket}/images/{type}/{year}/{month}/{day}/{userId}/{fileName}
  return `images/${type}/${year}/${month}/${day}/${userId}/${fileName}`;
}

// ÌååÏùº ÌÅ¨Í∏∞ Ï†úÌïú Ï≤¥ÌÅ¨ (10MB)
function validateFileSize(buffer: Buffer): boolean {
  const maxSize = 10 * 1024 * 1024; // 10MB
  return buffer.length <= maxSize;
}

// ÌóàÏö©Îêú Ïù¥ÎØ∏ÏßÄ ÌòïÏãù Ï≤¥ÌÅ¨
function validateImageFormat(fileName: string): boolean {
  const allowedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];
  const extension = fileName.split('.').pop()?.toLowerCase();
  return extension ? allowedExtensions.includes(extension) : false;
}

// ÌååÏùº Ï†ïÎ¶¨ Ìï®Ïàò (Ïò§ÎûòÎêú ÏûÑÏãú ÌååÏùº ÏÇ≠Ï†ú)
export const cleanupTempFiles = async (event: any) => {
  try {
    const tempDir = path.join(__dirname, 'files');
    const maxAge = 24 * 60 * 60 * 1000; // 24ÏãúÍ∞Ñ
    const now = Date.now();
    let deletedCount = 0;
    
    function cleanupDirectory(dirPath: string) {
      if (!fs.existsSync(dirPath)) return;
      
      const items = fs.readdirSync(dirPath);
      for (const item of items) {
        const itemPath = path.join(dirPath, item);
        const stats = fs.statSync(itemPath);
        
        if (stats.isDirectory()) {
          cleanupDirectory(itemPath);
          // Îπà ÎîîÎ†âÌÜ†Î¶¨ ÏÇ≠Ï†ú
          if (fs.readdirSync(itemPath).length === 0) {
            fs.rmdirSync(itemPath);
          }
        } else if (stats.isFile()) {
          // ÏûÑÏãú ÌååÏùºÏù¥Í≥† 24ÏãúÍ∞Ñ Ïù¥ÏÉÅ Îêú Í≤ΩÏö∞ ÏÇ≠Ï†ú
          if (now - stats.mtime.getTime() > maxAge) {
            fs.unlinkSync(itemPath);
            deletedCount++;
          }
        }
      }
    }
    
    cleanupDirectory(tempDir);
    
    await appendLog({
      type: 'file_cleanup',
      userId: '',
      result: 'success',
      detail: { deletedCount },
      action: 'ÌååÏùº Ï†ïÎ¶¨',
      screen: 'AdminScreen',
      component: 'file_cleanup'
    });
    
    return { 
      statusCode: 200, 
      body: JSON.stringify({ 
        message: 'File cleanup completed',
        deletedCount 
      }) 
    };
  } catch (error: any) {
    console.error('ÌååÏùº Ï†ïÎ¶¨ ÏóêÎü¨:', error);
    
    await appendLog({
      type: 'file_cleanup',
      userId: '',
      result: 'fail',
      message: error.message,
      detail: { error: error.message },
      action: 'ÌååÏùº Ï†ïÎ¶¨',
      screen: 'AdminScreen',
      component: 'file_cleanup'
    });
    
    return { 
      statusCode: 500, 
      body: JSON.stringify({ error: 'File cleanup failed' }) 
    };
  }
};

export const getTerms = async () => {
  const terms = readJson(termsPath);
  return { statusCode: 200, body: JSON.stringify(snakeToCamelCase(terms)) };
};

export const getPrivacy = async () => {
  const privacy = readJson(privacyPath);
  return { statusCode: 200, body: JSON.stringify(snakeToCamelCase(privacy)) };
};

export const getCustomerService = async () => {
  const cs = readJson(customerServicePath);
  return { statusCode: 200, body: JSON.stringify(snakeToCamelCase(cs)) };
};

// Îß§Ïπ≠ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï°∞Ìöå (matchId Í∏∞Î∞ò)
export const getMatchDetail = async (event: any) => {
  const matchId = event.pathParameters?.matchId;
  const requestUserId = event.queryStringParameters?.userId || event.headers?.userid;
  
  if (!matchId) {
    return { statusCode: 400, body: JSON.stringify({ error: 'matchId required' }) };
  }
  
  if (!requestUserId) {
    return { statusCode: 400, body: JSON.stringify({ error: 'userId required' }) };
  }
  
  const matchPairs = readJson(matchPairsPath);
  const profiles = readJson(profilesPath);
  const preferences = readJson(preferencesPath);
  
  // Í∏∞Ï°¥: const match = matchPairs.find((m: any) => m.match_id === matchId);
  const match = matchPairs.find((m: any) => m.match_a_id === matchId || m.match_b_id === matchId);
  if (!match) {
    await appendLog({
      type: 'get_match_detail',
      userId: requestUserId,
      result: 'fail',
      message: 'Match not found',
      detail: { requestedMatchId: matchId },
      action: 'Îß§Ïπ≠ ÏÉÅÏÑ∏ Ï°∞Ìöå',
      screen: 'UserDetailScreen',
      component: 'match_detail'
    });
    return { statusCode: 404, body: JSON.stringify({ error: 'Match not found' }) };
  }
  
  // ÏöîÏ≤≠Ìïú ÏÇ¨Ïö©ÏûêÍ∞Ä Îß§Ïπ≠Ïóê Ìè¨Ìï®ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
  const matchingRequests = readJson(matchingRequestsPath);
  const matchA = matchingRequests.find((r: any) => r.match_id === match.match_a_id);
  const matchB = matchingRequests.find((r: any) => r.match_id === match.match_b_id);

  if (
    (matchA && matchA.requester_id === requestUserId) ||
    (matchB && matchB.requester_id === requestUserId)
  ) {
    // OK, Í≥ÑÏÜç ÏßÑÌñâ
  } else {
    await appendLog({
      type: 'get_match_detail',
      userId: requestUserId,
      result: 'fail',
      message: 'User not in match',
      detail: { requestedMatchId: matchId, userA: matchA?.requester_id, userB: matchB?.requester_id },
      action: 'Îß§Ïπ≠ ÏÉÅÏÑ∏ Ï°∞Ìöå',
      screen: 'UserDetailScreen',
      component: 'match_detail'
    });
    return { statusCode: 403, body: JSON.stringify({ error: 'User not authorized for this match' }) };
  }
  
  // Îß§Ïπ≠Îêú ÏÉÅÎåÄÎ∞©Ïùò userId Ï∞æÍ∏∞
  let otherUserId = null;
  if (matchA && matchA.requester_id === requestUserId && matchB) {
    otherUserId = matchB.requester_id;
  } else if (matchB && matchB.requester_id === requestUserId && matchA) {
    otherUserId = matchA.requester_id;
  }
  
  const profile = profiles.find((p: any) => p.user_id === otherUserId);
  const preference = preferences.find((p: any) => p.user_id === otherUserId);
  
  const result = {
    matchId: match.match_id,
    userId: otherUserId,
    profile: profile || null,
    preference: preference || null,
    matchDate: match.final_date || null,
    status: match.final_date ? 'revealed' : 'pending'
  };
  
  await appendLog({
    type: 'get_match_detail',
    userId: requestUserId,
    result: 'success',
    detail: { 
      matchId: match.match_id,
      otherUserId,
      profileFound: !!profile,
      preferenceFound: !!preference
    },
    action: 'Îß§Ïπ≠ ÏÉÅÏÑ∏ Ï°∞Ìöå',
    screen: 'UserDetailScreen',
    component: 'match_detail'
  });
  
  return { statusCode: 200, body: JSON.stringify(snakeToCamelCase(result)) };
}; 

// Îß§Ïπ≠ ÏÉÅÌÉú Ï°∞Ìöå: Ìï≠ÏÉÅ matchId, matchedUserÎ•º ÏùëÎãµÏóê Ìè¨Ìï® (ÏóÜÏúºÎ©¥ null)
export const getMatchingStatus = async (event: any) => {
  const userId = event.queryStringParameters?.userId || event.headers?.userid;
  if (!userId) {
    return { statusCode: 400, body: JSON.stringify({ error: 'userId required' }) };
  }
  // matching-requestsÏóêÏÑú Ïã†Ï≤≠ Í∏∞Î°ù Ï°∞Ìöå
  const matchingRequestsPath = path.join(__dirname, 'data/matching-requests.json');
  const matchingRequests = fs.existsSync(matchingRequestsPath) ? readJson(matchingRequestsPath) : [];
  const myRequest = matchingRequests.find((req: any) => req.requester_id === userId);
  let status = null;
  let matchId = null;
  let matchedUser = null;
  if (myRequest) {
    status = myRequest.status; // waiting, propose, matched, confirmed, scheduled, failed
    matchId = myRequest.match_id;
  }
  // match-pairsÏóêÏÑú ÎÇ¥ userIdÍ∞Ä Ìè¨Ìï®Îêú Ïåç Ï∞æÍ∏∞ (Ïã†Ï≤≠ÏûêÍ∞Ä ÏïÑÎãàÎçîÎùºÎèÑ)
  const matchPairs = readJson(path.join(__dirname, 'data/match-pairs.json'));
  const profiles = readJson(path.join(__dirname, 'data/profiles.json'));
  const myMatch = matchPairs.find((m: any) => {
    // matching-requestsÏóêÏÑú ÎÇ¥ userIdÍ∞Ä Ìè¨Ìï®Îêú match_idÎ•º Ï∞æÍ∏∞ ÏúÑÌï¥
    const matchA = matchingRequests.find((r: any) => r.match_id === m.match_a_id);
    const matchB = matchingRequests.find((r: any) => r.match_id === m.match_b_id);
    return (matchA && matchA.requester_id === userId) || (matchB && matchB.requester_id === userId);
  });
  if (myMatch) {
    const matchA = matchingRequests.find((r: any) => r.match_id === myMatch.match_a_id);
    const matchB = matchingRequests.find((r: any) => r.match_id === myMatch.match_b_id);
    let otherUserId = null;
    if (matchA && matchA.requester_id === userId && matchB) {
      otherUserId = matchB.requester_id;
    } else if (matchB && matchB.requester_id === userId && matchA) {
      otherUserId = matchA.requester_id;
    }
    if (otherUserId) {
      const profile = profiles.find((p: any) => p.user_id === otherUserId);
      if (profile) {
        matchedUser = {
          userId: profile.user_id,
          name: profile.name || '',
          job: profile.job || '',
          region: profile.region?.region || '',
          photoUrl: profile.photos?.[0] || null,
        };
      }
    }
  }
  // Ìï≠ÏÉÅ matchId, matchedUser Ìè¨Ìï® (ÏóÜÏúºÎ©¥ null)
  await appendLog({ 
    type: 'get_matching_status', 
    userId, 
    result: 'success', 
    detail: { status, matchedUserId: matchedUser?.userId },
    action: 'Îß§Ïπ≠ÏÉÅÌÉú Ï°∞Ìöå',
    screen: 'MainScreen',
    component: 'matching_status'
  });
  return { statusCode: 200, body: JSON.stringify({ status, matchId, matchedUser }) };
}; 

// [Ïã†Í∑ú] Ïù∏ÏÇ¨Ïù¥Ìä∏ API (ÎçîÎØ∏)
export const getInsight = async (event: any) => {
  const { userId } = event.pathParameters || {};
  // Ïã§Ï†ú Íµ¨ÌòÑ Ï†ÑÍπåÏßÄ ÎçîÎØ∏ Îç∞Ïù¥ÌÑ∞ Î∞òÌôò
  if (!userId) {
    return { statusCode: 400, body: JSON.stringify({ error: 'userId required' }) };
  }
  // ÏòàÏãú: Îß§Ïπ≠ ÌöüÏàò, ÏÑ±Í≥µÎ•†, ÏµúÍ∑º ÌôúÎèô Îì±
  const dummy = {
    userId,
    totalMatches: 5,
    successfulMatches: 2,
    lastActive: new Date().toISOString(),
    favoriteRegion: 'ÏÑúÏö∏',
    pointsUsed: 300,
    reviewScore: 4.2,
    // ... Í∏∞ÌÉÄ ÌÜµÍ≥Ñ
  };
  return { statusCode: 200, body: JSON.stringify(dummy) };
}; 

// ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå
export const getHistory = async (event: any) => {
  try {
    const userId = event.pathParameters?.userId;
    
    if (!userId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'userId is required' })
      };
    }

    // Îß§Ïπ≠ ÏöîÏ≤≠ ÌûàÏä§ÌÜ†Î¶¨
    const matchingRequests = readJson(matchingRequestsPath);
    const userMatchingRequests = matchingRequests.filter((req: any) => req.requester_id === userId);

    // Îß§Ïπ≠ ÏÑ±ÏÇ¨ ÌûàÏä§ÌÜ†Î¶¨
    const matchPairs = readJson(matchPairsPath);
    const userMatchPairs = matchPairs.filter((pair: any) => {
      const matchA = matchingRequests.find((req: any) => req.match_id === pair.match_a_id);
      const matchB = matchingRequests.find((req: any) => req.match_id === pair.match_b_id);
      return (matchA && matchA.requester_id === userId) || (matchB && matchB.requester_id === userId);
    });

    // Ìè¨Ïù∏Ìä∏ ÌûàÏä§ÌÜ†Î¶¨
    const pointsHistory = readJson(pointsHistoryPath);
    const userPointsHistory = pointsHistory.filter((history: any) => history.user_id === userId);

    // ÏÉÅÌÉú Î≥ÄÍ≤Ω ÌûàÏä§ÌÜ†Î¶¨
    const statusHistory = readJson(userStatusHistoryPath);
    const userStatusHistory = statusHistory.filter((history: any) => history.user_id === userId);

    const history = {
      matchingRequests: userMatchingRequests,
      matchPairs: userMatchPairs,
      pointsHistory: userPointsHistory,
      statusHistory: userStatusHistory
    };

    await appendLog({
      type: 'get_history',
      userId: userId,
      result: 'success',
      message: 'ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå ÏÑ±Í≥µ',
      detail: { 
        matchingRequestsCount: userMatchingRequests.length,
        matchPairsCount: userMatchPairs.length,
        pointsHistoryCount: userPointsHistory.length,
        statusHistoryCount: userStatusHistory.length
      },
      action: 'ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå',
      screen: 'HistoryScreen',
      component: 'history'
    });

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify(history)
    };

  } catch (error: any) {
    console.error('getHistory error:', error);
    
    await appendLog({
      type: 'get_history',
      userId: event.pathParameters?.userId,
      result: 'fail',
      message: 'ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå Ïã§Ìå®',
      detail: { error: error.message },
      action: 'ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå',
      screen: 'HistoryScreen',
      component: 'history'
    });

    return {
      statusCode: 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify({ error: 'Internal server error' })
    };
  }
}; 

// Î¶¨ÏõåÎìú Ï°∞Ìöå
export const getReward = async (event: any) => {
  try {
    const userId = event.pathParameters?.userId;
    
    if (!userId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'userId is required' })
      };
    }

    // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ÏóêÏÑú ÌòÑÏû¨ Ìè¨Ïù∏Ìä∏ Ï°∞Ìöå
    const users = readJson(usersPath);
    const user = users.find((u: any) => u.user_id === userId);
    
    if (!user) {
      return {
        statusCode: 404,
        body: JSON.stringify({ error: 'User not found' })
      };
    }

    // Ìè¨Ïù∏Ìä∏ ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå
    const pointsHistory = readJson(pointsHistoryPath);
    const userPointsHistory = pointsHistory.filter((history: any) => history.user_id === userId);

    // Î¶¨ÏõåÎìú Ï†ïÎ≥¥ Íµ¨ÏÑ±
    const reward = {
      currentPoints: user.points || 0,
      totalEarned: userPointsHistory
        .filter((h: any) => h.type === 'earn')
        .reduce((sum: number, h: any) => sum + (h.points || 0), 0),
      totalSpent: userPointsHistory
        .filter((h: any) => h.type === 'spend')
        .reduce((sum: number, h: any) => sum + (h.points || 0), 0),
      pointsHistory: userPointsHistory.slice(-10), // ÏµúÍ∑º 10Í∞ú Í∏∞Î°ù
      availableRewards: [
        { id: 'reward-1', name: 'ÌîÑÎ¶¨ÎØ∏ÏóÑ Îß§Ïπ≠', points: 100, description: 'Îçî Ï†ïÌôïÌïú Îß§Ïπ≠ÏùÑ ÏúÑÌïú ÌîÑÎ¶¨ÎØ∏ÏóÑ ÏÑúÎπÑÏä§' },
        { id: 'reward-2', name: 'ÌîÑÎ°úÌïÑ Î∂ÄÏä§ÌÑ∞', points: 50, description: 'ÌîÑÎ°úÌïÑÏùÑ ÏÉÅÎã®Ïóê ÎÖ∏Ï∂úÏãúÌÇ§Îäî ÏÑúÎπÑÏä§' },
        { id: 'reward-3', name: 'Ï∂îÍ∞Ä ÏÜåÍ∞úÌåÖ', points: 200, description: 'Ï∂îÍ∞Ä ÏÜåÍ∞úÌåÖ Í∏∞Ìöå Ï†úÍ≥µ' }
      ]
    };

    await appendLog({
      type: 'get_reward',
      userId: userId,
      result: 'success',
      message: 'Î¶¨ÏõåÎìú Ï°∞Ìöå ÏÑ±Í≥µ',
      detail: { 
        currentPoints: reward.currentPoints,
        totalEarned: reward.totalEarned,
        totalSpent: reward.totalSpent,
        historyCount: userPointsHistory.length
      },
      action: 'Î¶¨ÏõåÎìú Ï°∞Ìöå',
      screen: 'RewardScreen',
      component: 'reward'
    });

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify(reward)
    };

  } catch (error: any) {
    console.error('getReward error:', error);
    
    await appendLog({
      type: 'get_reward',
      userId: event.pathParameters?.userId,
      result: 'fail',
      message: 'Î¶¨ÏõåÎìú Ï°∞Ìöå Ïã§Ìå®',
      detail: { error: error.message },
      action: 'Î¶¨ÏõåÎìú Ï°∞Ìöå',
      screen: 'RewardScreen',
      component: 'reward'
    });

    return {
      statusCode: 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify({ error: 'Internal server error' })
    };
  }
}; 